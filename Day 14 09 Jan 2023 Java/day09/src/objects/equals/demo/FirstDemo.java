package objects.equals.demo;

import java.util.Objects;

public class FirstDemo {

	public static void main(String[] args) {
//		primitiveTypeComparison();
//		howJavaCompareTwoObjectsDefault();
//		howJavaCompateTwoObjectsDefault2();
		howJavaCompareTwoObjectsWithCustomEquals();
//		howStringComparisonWorks();

	}

	private static void primitiveTypeComparison() {
		System.out.println('A' == 'a' ? "'A'=='a'" : "'A'!='a'");
		System.out.println(10.20f == 10.20 ? "10.20f==10.20d" : "10.20f!=10.20d");
		System.out.println(10 == 10 ? "10.00 == 10" : "10.00 != 10");
		System.out.println('A' == 65 ? "'A' == 65" : "'A' != 65");
	}

	private static void howJavaCompareTwoObjectsDefault() {
		Car bmw = new Car("BMW X7", 3000000L);
		Car jaguar = new Car("Jaguar", 4500000L);

		System.out.println(bmw);
		System.out.println(jaguar);

		// To check the instance address we can use above three methods.
		System.out.println("bmw.hashCode():" + bmw.hashCode());
		System.out.println("bmw Hex Address:" + Integer.toHexString(bmw.hashCode()).toUpperCase());
		System.out.println("bmw Identity Hash Address:" + System.identityHashCode(bmw));
		System.out.println("jaguar.hashCode():" + jaguar.hashCode());

		// == comparison
		System.out.println(bmw == jaguar ? "bmw == jaguar" : "bmw != jaguar");

		// hashCode() method is overridden & suppose to be used for collections map
		// framework and does not produce unique addresses.
		//
		// To get the hexString as printed by sysout(bmw) we can use
		// Integer.toHexString(bmw.hashCode()) method.
		//
		//
		// The best method to get the actula hashCode will be
		// System.identityHashCode(bmw).
		//

	}

	private static void howJavaCompateTwoObjectsDefault2() {
		Car bmw = new Car("BMW X7", 3000000L);
		Car bmw2 = new Car("BMW X7", 3000000L);
		System.out.println(bmw.hashCode());
		System.out.println(bmw2.hashCode());
		System.out.println(bmw == bmw2 ? "bmw==bmw2" : "bmw!=bmw2");

		bmw2 = bmw;
		System.out.println(bmw.hashCode());
		System.out.println(bmw2.hashCode());
		System.out.println(bmw == bmw2 ? "bmw==bmw2" : "bmw!=bmw2");

		System.out.println(bmw.equals(bmw2) ? "bmw.equals(bmw2)" : "!bmw.equals(bmw2)");

		/**
		 * Conclusion in Java by default-
		 * 
		 * 1. == compares the physical addresses of two object.
		 * 
		 * 2. object1.equals(object2) compares internally the addresses using ==
		 * comparison
		 * 
		 * Check Code github
		 * openjdk:https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/Object.java
		 * 
		 * public boolean equals(Object obj) { return (this== obj); }
		 * 
		 * Additional Reference: https://www.baeldung.com/java-hashcode
		 * 
		 * Understanding How hashCode() Works Simply put, hashCode() returns an integer
		 * value, generated by a hashing algorithm.
		 * 
		 * Objects that are equal (according to their equals()) must return the same
		 * hash code. Different objects do not need to return different hash codes.
		 * 
		 * The general contract of hashCode() states:
		 * 
		 * Whenever it is invoked on the same object more than once during an execution
		 * of a Java application, hashCode() must consistently return the same value,
		 * provided no information used in equals comparisons on the object is modified.
		 * This value doesn't need to stay consistent from one execution of an
		 * application to another execution of the same application.
		 * 
		 * If two objects are equal according to the equals(Object) method, calling the
		 * hashCode() method on each of the two objects must produce the same value.
		 * 
		 * If two objects are unequal according to the equals(java.lang.Object) method,
		 * calling the hashCode method on each of the two objects doesn't need to
		 * produce distinct integer results. However, developers should be aware that
		 * producing distinct integer results for unequal objects improves the
		 * performance of hash tables.
		 * 
		 * “As much as is reasonably practical, the hashCode() method defined by class
		 * Object does return distinct integers for distinct objects. (This is typically
		 * implemented by converting the internal address of the object into an integer,
		 * but this implementation technique is not required by the JavaTM programming
		 * language.)”
		 * 
		 */

	}

	private static void howJavaCompareTwoObjectsWithCustomEquals() {
		Car bmw = new Car("BMW X7", 3000000L);
		Car bmw2 = new Car("BMW X7", 3000000L);
		System.out.println(bmw.hashCode());
		System.out.println(bmw2.hashCode());
		System.out.println(bmw == bmw2 ? "bmw==bmw2" : "bmw!=bmw2");
		System.out.println(bmw.equals(bmw2) ? "bmw.equals(bmw2)" : "!bmw.equals(bmw2)");

	}

	private static void howStringComparisonWorks() {
		String s1 = "Hi";
		String s2 = "Hi";
		String s3 = new String("Hi");
		System.out.println(s1 == s2 ? "s1==s2" : "s1!=s2");
		System.out.println(s1 == s3 ? "s1==s3" : "s1!=s3");

		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
		System.out.println(s3.hashCode());

		System.out.println("s1:" + System.identityHashCode(s1));
		System.out.println("s2:" + System.identityHashCode(s2));
		System.out.println("s3:" + System.identityHashCode(s3));

	}
}

class Car extends Object {
	private String modelName;
	private long price;

	public Car() {
		super();
		// TODO Auto-generated constructor stub
	}

	public Car(String modelName, long price) {
		super();
		this.modelName = modelName;
		this.price = price;
	}

	public String getModelName() {
		return modelName;
	}

	public void setModelName(String modelName) {
		this.modelName = modelName;
	}

	public long getPrice() {
		return price;
	}

	public void setPrice(long price) {
		this.price = price;
	}

	@Override
	public String toString() {
		return "Car [modelName=" + modelName + ", price=" + price + "]";
	}

	/**
	 * 
	 * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#:~:text=The%20equals%20method%20for%20class,y%20has%20the%20value%20true%20).
	 * 
	 * The equals method implements an equivalence relation on non-null object
	 * references:
	 * 
	 * It is reflexive: for any non-null reference value x, x.equals(x) should
	 * return true. It is symmetric: for any non-null reference values x and y,
	 * x.equals(y) should return true if and only if y.equals(x) returns true. It is
	 * transitive: for any non-null reference values x, y, and z, if x.equals(y)
	 * returns true and y.equals(z) returns true, then x.equals(z) should return
	 * true. It is consistent: for any non-null reference values x and y, multiple
	 * invocations of x.equals(y) consistently return true or consistently return
	 * false, provided no information used in equals comparisons on the objects is
	 * modified. For any non-null reference value x, x.equals(null) should return
	 * false.
	 */

//	@Override
//	public boolean equals(Object obj) {
//		Car toBeCompared = (Car) obj;
//		if (this.modelName.equals(toBeCompared.modelName) && this.price == toBeCompared.price) {
//			return true;
//		} else {
//			return false;
//		}
//	}

	
}